<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
 <meta>
  <!-- Stylesheets -->
  <link href="../web.css" type="text/css" rel="stylesheet"></link>
  <link href="../pygmentize.css" type="text/css" rel="stylesheet"></link>
  <title>VLFeat - Documentation - C API</title>
  

  <!-- Scripts-->
  
 </meta>

 <!-- Body Start -->
 <body>
  <div id="header">
   <!-- Google CSE Search Box Begins -->
   <form action="http://www.vlfeat.org/search.html" method="get" id="cse-search-box" enctype="application/x-www-form-urlencoded">
    <div>
     <input type="hidden" name="cx" value="003215582122030917471:oq23albfeam"></input>
     <input type="hidden" name="cof" value="FORID:11"></input>
     <input type="hidden" name="ie" value="UTF-8"></input>
     <input type="text" name="q" size="31"></input>
     <input type="submit" name="sa" value="Search"></input>
    </div>
   </form>
   <script src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" xml:space="preserve" type="text/javascript"></script>
   <!-- Google CSE Search Box Ends -->
   <h1><a shape="rect" href="../index.html" class="plain"><span id="vlfeat">VLFeat</span><span id="dotorg">.org</span></a></h1>
  </div>
  <div id="headbanner">
   Documentation - C API
  </div>
  <div id="pagebody">
   <div id="sidebar"> <!-- Navigation Start -->
    <ul>
<li><a href="../index.html">Home</a>
</li>
<li><a href="../download.html">Download</a>
</li>
<li><a href="../doc.html">Documentation</a>
<ul>
<li><a href="../mdoc/mdoc.html">Matlab API</a>
</li>
<li><a href="index.html" class='active' >C API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
</ul></li>
<li><a href="../overview/tut.html">Tutorials</a>
</li>
<li><a href="../applications/apps.html">Applications</a>
</li>
</ul>

   </div> <!-- sidebar -->
   <div id="content">
    
    <div class="doxygen">
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<h1>sift.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Scale Invariant Feature Transform (SIFT)  
<a href="#_details">More...</a></p>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="generic_8h.html">generic.h</a>&quot;</code><br/>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SIFT filter keypoint.  <a href="structVlSiftKeypoint.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SIFT filter.  <a href="structVlSiftFilt.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7efac4fb08e4642f12ef439ac376a5cc"></a><!-- doxytag: member="sift.h::vl_sift_pix" ref="a7efac4fb08e4642f12ef439ac376a5cc" args="" -->
typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SIFT filter pixel type. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Create and destroy</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#adff66a155e30ed412bc8bbb97dfa2fae">vl_sift_new</a> (int width, int height, int noctaves, int nlevels, int o_min)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new SIFT filter.  <a href="#adff66a155e30ed412bc8bbb97dfa2fae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#ab242293326626641411e7d7f43a109b2">vl_sift_delete</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete SIFT filter.  <a href="#ab242293326626641411e7d7f43a109b2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Process data</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a97cca9a09efaadc9dd0671912b9d5e05">vl_sift_process_first_octave</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, <a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> const *im)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start processing a new image.  <a href="#a97cca9a09efaadc9dd0671912b9d5e05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a610cab1a3bf7d38e389afda9037f14da">vl_sift_process_next_octave</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Process next octave.  <a href="#a610cab1a3bf7d38e389afda9037f14da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a65c55820964f4f6609ca9ef1d547b2c4">vl_sift_detect</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect keypoints.  <a href="#a65c55820964f4f6609ca9ef1d547b2c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a2e409d464f81582dc3e839bf0fece66e">vl_sift_calc_keypoint_orientations</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, double angles[4], <a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> const *k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the keypoint orientation(s)  <a href="#a2e409d464f81582dc3e839bf0fece66e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a19140d86df12ff8c211c2728209de9b1">vl_sift_calc_keypoint_descriptor</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, <a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> *descr, <a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> const *k, double angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the descriptor of a keypoint.  <a href="#a19140d86df12ff8c211c2728209de9b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a46d3e864618b4a940c2099b7c1f7b6a6">vl_sift_calc_raw_descriptor</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f, <a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> const *image, <a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> *descr, int widht, int height, double x, double y, double s, double angle0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the SIFT descriptor on raw data.  <a href="#a46d3e864618b4a940c2099b7c1f7b6a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a6f3fc8e38b6c0c520cb90b1a63ddc031">vl_sift_keypoint_init</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f, <a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> *k, double x, double y, double sigma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a keypoint from its position and scale.  <a href="#a6f3fc8e38b6c0c520cb90b1a63ddc031"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Retrieve data and parameters</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a70186e579c8eff1bcabf408f46169cad">vl_sift_get_octave_index</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current octave index.  <a href="#a70186e579c8eff1bcabf408f46169cad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a5e0cd96b3985635b82adabc3ce8b2242">vl_sift_get_noctaves</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of octaves.  <a href="#a5e0cd96b3985635b82adabc3ce8b2242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#aa3db07e91c86f992c31b8e2335a760a9">vl_sift_get_octave_first</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first octave.  <a href="#aa3db07e91c86f992c31b8e2335a760a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a89bd76ab5c1e584ff8e46dfdc93ea748">vl_sift_get_octave_width</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current octave width.  <a href="#a89bd76ab5c1e584ff8e46dfdc93ea748"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a9769e8f6d84ec75804e873229526eb10">vl_sift_get_octave_height</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current octave height.  <a href="#a9769e8f6d84ec75804e873229526eb10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a751c116352e72eed8a111e7c1e06a18e">vl_sift_get_nlevels</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of levels per octave.  <a href="#a751c116352e72eed8a111e7c1e06a18e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#aa45b8e7413384c7d6525f439e68856fe">vl_sift_get_nkeypoints</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of keypoints.  <a href="#aa45b8e7413384c7d6525f439e68856fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a08959e6a90c98bf397e3430e79a6ea9c">vl_sift_get_peak_thresh</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get peaks treashold.  <a href="#a08959e6a90c98bf397e3430e79a6ea9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#adb5b0159af92e1ce1462ddaaaa55a747">vl_sift_get_edge_thresh</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get edges threshold.  <a href="#adb5b0159af92e1ce1462ddaaaa55a747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#ad4b57c390ca004dc56b0b0b1abf0c7a9">vl_sift_get_norm_thresh</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get norm threshold.  <a href="#ad4b57c390ca004dc56b0b0b1abf0c7a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#ae0272723812d5072619475d4787be78e">vl_sift_get_magnif</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the magnification factor.  <a href="#ae0272723812d5072619475d4787be78e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a76053a5e655b9577995fea0fbe429078">vl_sift_get_window_size</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Gaussian window size.  <a href="#a76053a5e655b9577995fea0fbe429078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a400759060e87dc7a6264555b90b0a221">vl_sift_get_octave</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f, int s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current octave data.  <a href="#a400759060e87dc7a6264555b90b0a221"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a8d7878f102c5e09b2df06b3662ed9c6a">vl_sift_get_keypoints</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get keypoints.  <a href="#a8d7878f102c5e09b2df06b3662ed9c6a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Set parameters</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#af69118a1c5d4d17bccac87d11fe8ce8f">vl_sift_set_peak_thresh</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, double t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set peaks threshold.  <a href="#af69118a1c5d4d17bccac87d11fe8ce8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#ab7173b402b85de43ebf36fcabde77508">vl_sift_set_edge_thresh</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, double t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set edges threshold.  <a href="#ab7173b402b85de43ebf36fcabde77508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a86703f33aad31638909acd9697f93115">vl_sift_set_norm_thresh</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, double t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set norm threshold.  <a href="#a86703f33aad31638909acd9697f93115"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#a595579dd7952807c074c5311a6500121">vl_sift_set_magnif</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, double m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the magnification factor.  <a href="#a595579dd7952807c074c5311a6500121"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sift_8h.html#af5996cc6171c6e3c8810fb400abbad21">vl_sift_set_window_size</a> (<a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *f, double x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Gaussian window size.  <a href="#af5996cc6171c6e3c8810fb400abbad21"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="author"><dt><b>Author:</b></dt><dd>Andrea Vedaldi</dd></dl>
<dl class="user"><dt><b>Credits:</b></dt><dd>May people have contributed with suggestions and bug reports. Although the following list is certainly incomplete, we would like to thank: Brian Fulkerson, Wei Dong, Loic, Giuseppe, Liu, Erwin, P. Ivanov, and Q. S. Luo.</dd></dl>
<h2><a class="anchor" id="sift"></a>
Scale Invariant Feature Transform</h2>
<p>This library module implements a <a class="el" href="sift_8h.html#sift-usage">SIFT filter object</a>, a reusable object to extract SIFT features from one or multiple images of the same size.</p>
<ul>
<li><a class="el" href="sift_8h.html#sift-intro">Overview</a><ul>
<li><a class="el" href="sift_8h.html#sift-intro-detector">SIFT detector</a></li>
<li><a class="el" href="sift_8h.html#sift-intro-descriptor">SIFT Descriptor</a></li>
<li><a class="el" href="sift_8h.html#sift-intro-extensions">Extensions</a></li>
</ul>
</li>
<li><a class="el" href="sift_8h.html#sift-usage">Using the SIFT filter object</a></li>
<li><a class="el" href="sift_8h.html#sift-tech">Technical details</a><ul>
<li><a class="el" href="sift_8h.html#sift-tech-ss">Scale space</a></li>
<li><a class="el" href="sift_8h.html#sift-tech-detector">Detector</a><ul>
<li><a class="el" href="sift_8h.html#sift-tech-detector-peak">Eliminating low contrast responses</a></li>
<li><a class="el" href="sift_8h.html#sift-tech-detector-edge">Eliminating edge responses</a></li>
<li><a class="el" href="sift_8h.html#sift-tech-detector-orientation">Orientation assignment</a></li>
</ul>
</li>
<li><a class="el" href="sift_8h.html#sift-tech-descriptor">Descriptor</a><ul>
<li><a class="el" href="sift_8h.html#sift-tech-descriptor-can">Construction in the canonical frame</a></li>
<li><a class="el" href="sift_8h.html#sift-tech-descriptor-image">Calculation in the image frame</a></li>
<li><a class="el" href="sift_8h.html#sift-tech-descriptor-std">Standard SIFT descriptor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="sift-intro"></a>
Overview</h2>
<p>A SIFT feature is a selected image region (also called keypoint) with an associated descriptor. Keypoints are extracted by the <b><a class="el" href="sift_8h.html#sift-intro-detector">SIFT detector</a></b> and their descriptors are computed by the <b><a class="el" href="sift_8h.html#sift-intro-descriptor">SIFT descriptor</a></b>. It is also common to use independently the SIFT detector (i.e. computing the keypoints without descriptors) or the SIFT descriptor (i.e. computing descriptors of custom keypoints).</p>
<h3><a class="anchor" id="sift-intro-detector"></a>
SIFT detector</h3>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sift_8h.html#sift-tech-ss">Scale space technical details</a>, <a class="el" href="sift_8h.html#sift-tech-detector">Detector technical details</a></dd></dl>
<p>A SIFT <em>keypoint</em> is a circular image region with an orientation. It is described by a geometric <em>frame</em> of four parameters: the keypoint center coordinates <em>x</em> and <em>y</em>, its <em>scale</em> (the radius of the region), and its <em>orientation</em> (an angle expressed in radians). The SIFT detector uses as keypoints image structures which resemble &ldquo;blobs&rdquo;. By searching for blobs at multiple scales and positions, the SIFT detector is invariant (or, more accurately, covariant) to translation, rotations, and rescaling of the image.</p>
<p>The keypoint orientation is also determined from the local image appearance and is covariant to image rotations. Depending on the symmetry of the keypoint appearance, determining the orientation can be ambiguous. In this case, the SIFT detectors returns a list of up to four possible orientations, constructing up to four frames (differing only by their orientation) for each detected image blob.</p>
<div align="center">
<img src="sift-frame.png" alt="sift-frame.png"/>
<p><strong>SIFT keypoints are circular image regions with an orientation.</strong></p></div>
<p> There are several parameters that influence the detection of SIFT keypoints. First, searching keypoints at multiple scales is obtained by constructing a so-called &ldquo;Gaussian scale space&rdquo;. The scale space is just a collection of images obtained by progressively smoothing the input image, which is analogous to gradually reducing the image resolution. Conventionally, the smoothing level is called <em>scale</em> of the image. The construction of the scale space is influenced by the following parameters, set when creating the SIFT filter object by <a class="el" href="sift_8c.html#adff66a155e30ed412bc8bbb97dfa2fae" title="Create a new SIFT filter.">vl_sift_new()</a>:</p>
<ul>
<li><b>Number of octaves</b>. Increasing the scale by an octave means doubling the size of the smoothing kernel, whose effect is roughly equivalent to halving the image resolution. By default, the scale space spans as many octaves as possible (i.e. roughly <code> log2(min(width,height)</code>), which has the effect of searching keypoints of all possible sizes.</li>
<li><b>First octave index</b>. By convention, the octave of index 0 starts with the image full resolution. Specifying an index greater than 0 starts the scale space at a lower resolution (e.g. 1 halves the resolution). Similarly, specifying a negative index starts the scale space at an higher resolution image, and can be useful to extract very small features (since this is obtained by interpolating the input image, it does not make much sense to go past -1).</li>
<li><b>Number of levels per octave</b>. Each octave is sampled at this given number of intermediate scales (by default 3). Increasing this number might in principle return more refined keypoints, but in practice can make their selection unstable due to noise (see [1]).</li>
</ul>
<p>Keypoints are further refined by eliminating those that are likely to be unstable, either because they are selected nearby an image edge, rather than an image blob, or are found on image structures with low contrast. Filtering is controlled by the follow:</p>
<ul>
<li><b>Peak threshold.</b> This is the minimum amount of contrast to accept a keypoint. It is set by configuring the SIFT filter object by <a class="el" href="sift_8h.html#af69118a1c5d4d17bccac87d11fe8ce8f" title="Set peaks threshold.">vl_sift_set_peak_thresh()</a>.</li>
<li><b>Edge threshold.</b> This is the edge rejection threshold. It is set by configuring the SIFT filter object by <a class="el" href="sift_8h.html#ab7173b402b85de43ebf36fcabde77508" title="Set edges threshold.">vl_sift_set_edge_thresh()</a>.</li>
</ul>
<table class="doxtable">
<caption align="bottom">Summary of the parameters influencing the SIFT detector.</caption>
<tr style="font-weight:bold;">
<td>Parameter </td><td>See also </td><td>Controlled by </td><td>Comment  </td></tr>
<tr>
<td>number of octaves </td><td><a class="el" href="sift_8h.html#sift-intro-detector">SIFT detector</a>  </td><td><a class="el" href="sift_8h.html#adff66a155e30ed412bc8bbb97dfa2fae" title="Create a new SIFT filter.">vl_sift_new</a> </td><td></td></tr>
<tr>
<td>first octave index </td><td><a class="el" href="sift_8h.html#sift-intro-detector">SIFT detector</a>  </td><td><a class="el" href="sift_8h.html#adff66a155e30ed412bc8bbb97dfa2fae" title="Create a new SIFT filter.">vl_sift_new</a> </td><td>set to -1 to extract very small features  </td></tr>
<tr>
<td>number of scale levels per octave </td><td><a class="el" href="sift_8h.html#sift-intro-detector">SIFT detector</a>  </td><td><a class="el" href="sift_8h.html#adff66a155e30ed412bc8bbb97dfa2fae" title="Create a new SIFT filter.">vl_sift_new</a> </td><td>can affect the number of extracted keypoints  </td></tr>
<tr>
<td>edge threshold </td><td><a class="el" href="sift_8h.html#sift-intro-detector">SIFT detector</a>  </td><td><a class="el" href="sift_8h.html#ab7173b402b85de43ebf36fcabde77508" title="Set edges threshold.">vl_sift_set_edge_thresh</a> </td><td>decrease to eliminate more keypoints  </td></tr>
<tr>
<td>peak threshold </td><td><a class="el" href="sift_8h.html#sift-intro-detector">SIFT detector</a>  </td><td><a class="el" href="sift_8h.html#af69118a1c5d4d17bccac87d11fe8ce8f" title="Set peaks threshold.">vl_sift_set_peak_thresh</a> </td><td>increase to eliminate more keypoints  </td></tr>
</table>
<h3><a class="anchor" id="sift-intro-descriptor"></a>
SIFT Descriptor</h3>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sift_8h.html#sift-tech-descriptor">Descriptor technical details</a></dd></dl>
<p>A SIFT descriptor is a 3-D spatial histogram of the image gradients in characterizing the appearance of a keypoint. The gradient at each pixel is regarded as a sample of a three-dimensional elementary feature vector, formed by the pixel location and the gradient orientation. Samples are weighed by the gradient norm and accumulated in a 3-D histogram <em>h</em>, which (up to normalization and clamping) forms the SIFT descriptor of the region. An additional Gaussian weighting function is applied to give less importance to gradients farther away from the keypoint center. Orientations are quantized into eight bins and the spatial coordinates into four each, as follows:</p>
<div align="center">
<img src="sift-descr-easy.png" alt="sift-descr-easy.png"/>
<p><strong>The SIFT descriptor is a spatial histogram of the image gradient.</strong></p></div>
<p> SIFT descriptors are computed by either calling <a class="el" href="sift_8h.html#a19140d86df12ff8c211c2728209de9b1" title="Compute the descriptor of a keypoint.">vl_sift_calc_keypoint_descriptor</a> or <a class="el" href="sift_8h.html#a46d3e864618b4a940c2099b7c1f7b6a6" title="Run the SIFT descriptor on raw data.">vl_sift_calc_raw_descriptor</a>. They accept as input a keypoint frame, which specifies the descriptor center, its size, and its orientation on the image plane. The following parameters influence the descriptor calculation:</p>
<ul>
<li><b>magnification factor</b>. The descriptor size is determined by multiplying the keypoint scale by this factor. It is set by <a class="el" href="sift_8h.html#a595579dd7952807c074c5311a6500121" title="Set the magnification factor.">vl_sift_set_magnif</a>.</li>
<li><b>Gaussian window size</b>. The descriptor support is determined by a Gaussian window, which discounts gradient contributions farther away from the descriptor center. The standard deviation of this window is set by <a class="el" href="sift_8h.html#af5996cc6171c6e3c8810fb400abbad21" title="Set the Gaussian window size.">vl_sift_set_window_size</a> and expressed in unit of bins.</li>
</ul>
<p>VLFeat SIFT descriptor uses the following convention. The <em>y</em> axis points downwards and angles are measured clockwise (to be consistent with the standard image convention). The 3-D histogram (consisting of <img class="formulaInl" alt="$ 8 \times 4 \times 4 = 128 $" src="form_262.png"/> bins) is stacked as a single 128-dimensional vector, where the fastest varying dimension is the orientation and the slowest the <em>y</em> spatial coordinate. This is illustrated by the following figure.</p>
<div align="center">
<img src="sift-conv-vlfeat.png" alt="sift-conv-vlfeat.png"/>
<p><strong>VLFeat conventions</strong></p></div>
 <dl class="note"><dt><b>Note:</b></dt><dd>Keypoints (frames) D. Lowe's SIFT implementation convention is slightly different: The <em>y</em> axis points upwards and the angles are measured counter-clockwise.</dd></dl>
<div align="center">
<img src="sift-conv.png" alt="sift-conv.png"/>
<p><strong>D. Lowes' SIFT implementation conventions</strong></p></div>
 <table class="doxtable">
<caption align="bottom">Summary of the parameters influencing the SIFT descriptor.</caption>
<tr style="font-weight:bold;">
<td>Parameter </td><td>See also </td><td>Controlled by </td><td>Comment  </td></tr>
<tr>
<td>magnification factor </td><td><a class="el" href="sift_8h.html#sift-intro-descriptor">SIFT Descriptor</a>  </td><td><a class="el" href="sift_8h.html#a595579dd7952807c074c5311a6500121" title="Set the magnification factor.">vl_sift_set_magnif</a> </td><td>increase this value to enlarge the image region described  </td></tr>
<tr>
<td>Gaussian window size </td><td><a class="el" href="sift_8h.html#sift-intro-descriptor">SIFT Descriptor</a>  </td><td><a class="el" href="sift_8h.html#af5996cc6171c6e3c8810fb400abbad21" title="Set the Gaussian window size.">vl_sift_set_window_size</a> </td><td>smaller values let the center of the descriptor count more  </td></tr>
</table>
<h2><a class="anchor" id="sift-intro-extensions"></a>
Extensions</h2>
<p><b>Eliminating low-contrast descriptors.</b> Near-uniform patches do not yield stable keypoints or descriptors. <a class="el" href="sift_8h.html#a86703f33aad31638909acd9697f93115" title="Set norm threshold.">vl_sift_set_norm_thresh()</a> can be used to set a threshold on the average norm of the local gradient to zero-out descriptors that correspond to very low contrast regions. By default, the threshold is equal to zero, which means that no descriptor is zeroed. Normally this option is useful only with custom keypoints, as detected keypoints are implicitly selected at high contrast image regions.</p>
<h2><a class="anchor" id="sift-usage"></a>
Using the SIFT filter object</h2>
<p>The code provided in this module can be used in different ways. You can instantiate and use a <b>SIFT filter</b> to extract both SIFT keypoints and descriptors from one or multiple images. Alternatively, you can use one of the low level functions to run only a part of the SIFT algorithm (for instance, to compute the SIFT descriptors of custom keypoints).</p>
<p>To use a <b>SIFT filter</b> object:</p>
<ul>
<li>Initialize a SIFT filter object with <a class="el" href="sift_8c.html#adff66a155e30ed412bc8bbb97dfa2fae" title="Create a new SIFT filter.">vl_sift_new()</a>. The filter can be reused for multiple images of the same size (e.g. for an entire video sequence).</li>
<li>For each octave in the scale space:<ul>
<li>Compute the next octave of the DOG scale space using either <a class="el" href="sift_8c.html#a97cca9a09efaadc9dd0671912b9d5e05" title="Start processing a new image.">vl_sift_process_first_octave()</a> or <a class="el" href="sift_8c.html#a610cab1a3bf7d38e389afda9037f14da" title="Process next octave.">vl_sift_process_next_octave()</a> (stop processing if <a class="el" href="generic_8h.html#a67cc69e40d7af2aec137b36e53422982">VL_ERR_EOF</a> is returned).</li>
<li>Run the SIFT detector with <a class="el" href="sift_8c.html#a65c55820964f4f6609ca9ef1d547b2c4" title="Detect keypoints.">vl_sift_detect()</a> to get the keypoints.</li>
<li>For each keypoint:<ul>
<li>Use <a class="el" href="sift_8c.html#a2e409d464f81582dc3e839bf0fece66e" title="Calculate the keypoint orientation(s)">vl_sift_calc_keypoint_orientations()</a> to get the keypoint orientation(s).</li>
<li>For each orientation:<ul>
<li>Use <a class="el" href="sift_8c.html#a85f3878a53ef7151b569c1b3ea4d13b6" title="Compute the descriptor of a keypoint.">vl_sift_calc_keypoint_descriptor()</a> to get the keypoint descriptor.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Delete the SIFT filter by <a class="el" href="sift_8c.html#ab242293326626641411e7d7f43a109b2" title="Delete SIFT filter.">vl_sift_delete()</a>.</li>
</ul>
<p>To compute SIFT descriptors of custom keypoints, use <a class="el" href="sift_8c.html#a335f3295ba77b3bb937e5272fe1a02fc" title="Run the SIFT descriptor on raw data.">vl_sift_calc_raw_descriptor()</a>.</p>
<h2><a class="anchor" id="sift-tech"></a>
Technical details</h2>
<h3><a class="anchor" id="sift-tech-ss"></a>
Scale space</h3>
<p>In order to search for image blobs at multiple scale, the SIFT detector construct a scale space, defined as follows. Let <img class="formulaInl" alt="$I_0(\mathbf{x})$" src="form_263.png"/> denote an idealized <em>infinite resolution</em> image. Consider the <em>Gaussian kernel</em></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ g_{\sigma}(\mathbf{x}) = \frac{1}{2\pi\sigma^2} \exp \left( -\frac{1}{2} \frac{\mathbf{x}^\top\mathbf{x}}{\sigma^2} \right) \]" src="form_264.png"/>
</p>
<p>The <b>Gaussian scale space</b> is the collection of smoothed images</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ I_\sigma = g_\sigma * I, \quad \sigma \geq 0. \]" src="form_265.png"/>
</p>
<p>The image at infinite resolution <img class="formulaInl" alt="$ I_0 $" src="form_266.png"/> is useful conceptually, but is not available to us; instead, the input image <img class="formulaInl" alt="$ I_{\sigma_n} $" src="form_267.png"/> is assumed to be pre-smoothed at a nominal level <img class="formulaInl" alt="$ \sigma_n = 0.5 $" src="form_268.png"/> to account for the finite resolution of the pixels. Thus in practice the scale space is computed by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ I_\sigma = g_{\sqrt{\sigma^2 - \sigma_n^2}} * I_{\sigma_n}, \quad \sigma \geq \sigma_n. \]" src="form_269.png"/>
</p>
<p>Scales are sampled at logarithmic steps given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sigma = \sigma_0 2^{o+s/S}, \quad s = 0,\dots,S-1, \quad o = o_{\min}, \dots, o_{\min}+O-1, \]" src="form_270.png"/>
</p>
<p>where <img class="formulaInl" alt="$ \sigma_0 = 1.6 $" src="form_271.png"/> is the <em>base scale</em>, <img class="formulaInl" alt="$ o_{\min} $" src="form_272.png"/> is the <em>first octave index</em>, <em>O</em> the <em>number of octaves</em> and <em>S</em> the <em>number of scales per octave</em>.</p>
<p>Blobs are detected as local extrema of the <b>Difference of Gaussians</b> (DoG) scale space, obtained by subtracting successive scales of the Gaussian scale space:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathrm{DoG}_{\sigma(o,s)} = I_{\sigma(o,s+1)} - I_{\sigma(o,s)} \]" src="form_273.png"/>
</p>
<p>At each next octave, the resolution of the images is halved to save computations. The images composing the Gaussian and DoG scale space can then be arranged as in the following figure:</p>
<div align="center">
<img src="sift-ss.png" alt="sift-ss.png"/>
<p><strong>GSS and DoG scale space structures.</strong></p></div>
<p> The black vertical segments represent images of the Gaussian Scale Space (GSS), arranged by increasing scale <img class="formulaInl" alt="$\sigma$" src="form_274.png"/>. Notice that the scale level index <em>s</em> varies in a slightly redundant set</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ s = -1, \dots, S+2 \]" src="form_275.png"/>
</p>
<p>This simplifies glueing together different octaves and extracting DoG maxima (required by the SIFT detector).</p>
<h3><a class="anchor" id="sift-tech-detector"></a>
Detector</h3>
<p>The SIFT frames (keypoints) are extracted based on local extrema (peaks) of the DoG scale space. Numerically, local extrema are elements whose <img class="formulaInl" alt="$ 3 \times 3 \times 3 $" src="form_276.png"/> neighbors (in space and scale) have all smaller (or larger) value. Once extracted, local extrema are quadratically interpolated (this is very important especially at the lower resolution scales in order to have accurate keypoint localization at the full resolution). Finally, they are filtered to eliminate low-contrast responses or responses close to edges and the orientation(s) are assigned, as explained next.</p>
<h4><a class="anchor" id="sift-tech-detector-peak"></a>
Eliminating low contrast responses</h4>
<p>Peaks which are too short may have been generated by noise and are discarded. This is done by comparing the absolute value of the DoG scale space at the peak with the <b>peak threshold</b> <img class="formulaInl" alt="$t_p$" src="form_277.png"/> and discarding the peak its value is below the threshold.</p>
<h4><a class="anchor" id="sift-tech-detector-edge"></a>
Eliminating edge responses</h4>
<p>Peaks which are too flat are often generated by edges and do not yield stable features. These peaks are detected and removed as follows. Given a peak <img class="formulaInl" alt="$x,y,\sigma$" src="form_278.png"/>, the algorithm evaluates the <em>x</em>,<em>y</em> Hessian of of the DoG scale space at the scale <img class="formulaInl" alt="$\sigma$" src="form_274.png"/>. Then the following score (similar to the Harris function) is computed:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{(\mathrm{tr}\,D(x,y,\sigma))^2}{\det D(x,y,\sigma)}, \quad D = \left[ \begin{array}{cc} \frac{\partial^2 \mathrm{DoG}}{\partial x^2} &amp; \frac{\partial^2 \mathrm{DoG}}{\partial x\partial y} \\ \frac{\partial^2 \mathrm{DoG}}{\partial x\partial y} &amp; \frac{\partial^2 \mathrm{DoG}}{\partial y^2} \end{array} \right]. \]" src="form_279.png"/>
</p>
<p>This score has a minimum (equal to 4) when both eigenvalues of the Jacobian are equal (curved peak) and increases as one of the eigenvalues grows and the other stays small. Peaks are retained if the score is below the quantity <img class="formulaInl" alt="$(t_e+1)(t_e+1)/t_e$" src="form_280.png"/>, where <img class="formulaInl" alt="$t_e$" src="form_281.png"/> is the <b>edge threshold</b>. Notice that this quantity has a minimum equal to 4 when <img class="formulaInl" alt="$t_e=1$" src="form_282.png"/> and grows thereafter. Therefore the range of the edge threshold is <img class="formulaInl" alt="$[1,\infty)$" src="form_283.png"/>.</p>
<h3><a class="anchor" id="sift-tech-detector-orientation"></a>
Orientation assignment</h3>
<p>A peak in the DoG scale space fixes 2 parameters of the keypoint: the position and scale. It remains to choose an orientation. In order to do this, SIFT computes an histogram of the gradient orientations in a Gaussian window with a standard deviation which is 1.5 times bigger than the scale <img class="formulaInl" alt="$\sigma$" src="form_274.png"/> of the keypoint.</p>
<div align="center">
<img src="sift-orient.png" alt="sift-orient.png"/>
</div>
<p>This histogram is then smoothed and the maximum is selected. In addition to the biggest mode, up to other three modes whose amplitude is within the 80% of the biggest mode are retained and returned as additional orientations.</p>
<h3><a class="anchor" id="sift-tech-descriptor"></a>
Descriptor</h3>
<p>A SIFT descriptor of a local region (keypoint) is a 3-D spatial histogram of the image gradients. The gradient at each pixel is regarded as a sample of a three-dimensional elementary feature vector, formed by the pixel location and the gradient orientation. Samples are weighed by the gradient norm and accumulated in a 3-D histogram <em>h</em>, which (up to normalization and clamping) forms the SIFT descriptor of the region. An additional Gaussian weighting function is applied to give less importance to gradients farther away from the keypoint center.</p>
<h4><a class="anchor" id="sift-tech-descriptor-can"></a>
Construction in the canonical frame</h4>
<p>Denote the gradient vector field computed at the scale <img class="formulaInl" alt="$ \sigma $" src="form_257.png"/> by </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ J(x,y) = \nalba I_\sigma(x,y) = \left[\begin{array}{cc} \frac{\partial I_\sigma}{\partial x} &amp; \frac{\partial I_\sigma}{\partial y} &amp; \end{array}\right] \]" src="form_284.png"/>
</p>
<p>The descriptor is a 3-D spatial histogram capturing the distribution of <img class="formulaInl" alt="$ J(x,y) $" src="form_116.png"/>. It is convenient to describe its construction in the <em>canonical frame</em>. In this frame, the image and descriptor axes coincide and each spatial bin has side 1. The histogram has <img class="formulaInl" alt="$ N_\theta \times N_x \times N_y $" src="form_285.png"/> bins (usually <img class="formulaInl" alt="$ 8 \times 4 \times 4 $" src="form_286.png"/>), as in the following figure:</p>
<div align="center">
<img src="sift-can.png" alt="sift-can.png"/>
<p><strong>Canonical SIFT descriptor and spatial binning functions</strong></p></div>
<p>Bins are indexed by a triplet of indexes <em>t, i, j</em> and their centers are given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \theta_t &amp;=&amp; \frac{2\pi}{N_\theta} t, \quad t = 0,\dots,N_{\theta}-1, \\ x_i &amp;=&amp; i - \frac{N_x -1}{2}, \quad i = 0,\dots,N_x-1, \\ y_j &amp;=&amp; j - \frac{N_x -1}{2}, \quad j = 0,\dots,N_y-1. \\ \end{eqnarray*}" src="form_287.png"/>
</p>
<p>The histogram is computed by using trilinear interpolation, i.e. by weighing contributions by the <em>binning functions</em></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \displaystyle w(z) &amp;=&amp; \mathrm{max}(0, 1 - |z|), \\ \displaystyle w_\mathrm{ang}(z) &amp;=&amp; \sum_{k=-\infty}^{+\infty} w\left( \frac{N_\theta}{2\pi} z + N_\theta k \right). \end{eqnarray*}" src="form_288.png"/>
</p>
<p>The gradient vector field is transformed in a three-dimensional density map of weighed contributions</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(\theta, x, y) = |J(x,y)| \delta(\theta - \angle J(x,y)) \]" src="form_289.png"/>
</p>
<p>The historam is localized in the keypoint support by a Gaussian window of standard deviation <img class="formulaInl" alt="$ \sigma_{\mathrm{win}} $" src="form_290.png"/>. The histogram is then given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} h(t,i,j) &amp;=&amp; \int g_{\sigma_\mathrm{win}}(x,y) w_\mathrm{ang}(\theta - \theta_t) w(x-x_i) w(y-y_j) f(\theta,x,y) d\theta\,dx\,dy \\ &amp;=&amp; \int g_{\sigma_\mathrm{win}}(x,y) w_\mathrm{ang}(\angle J(x,y) - \theta_t) w(x-x_i) w(y-y_j) |J(x,y)|\,dx\,dy \end{eqnarray*}" src="form_291.png"/>
</p>
<p>In post processing, the histogram is <img class="formulaInl" alt="$ l^2 $" src="form_157.png"/> normalized, then clamped at 0.2, and <img class="formulaInl" alt="$ l^2 $" src="form_157.png"/> normalized again.</p>
<h4><a class="anchor" id="sift-tech-descriptor-image"></a>
Calculation in the image frame</h4>
<p>Invariance to similarity transformation is attained by attaching descriptors to SIFT keypoints (or other similarity-covariant frames). Then projecting the image in the canonical descriptor frames has the effect of undoing the image deformation.</p>
<p>In practice, however, it is convenient to compute the descriptor directly in the image frame. To do this, denote with a hat quantities relative to the canonical frame and without a hat quantities relative to the image frame (so for instance <img class="formulaInl" alt="$ \hat x $" src="form_292.png"/> is the <em>x-coordinate</em> in the canonical frame and <img class="formulaInl" alt="$ x $" src="form_88.png"/> the x-coordinate in the image frame). Assume that canonical and image frame are related by an affinity:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{x} = A \hat\mathbf{x} + T, \qquad \mathbf{x} = \left[\begin{array}{cc} x \\ y \end{arraty}\right], \quad \hat\mathbf{x} = \left[\begin{array}{cc} \hat x \\ \hat y \end{arraty}\right]. \]" src="form_293.png"/>
</p>
<div align="center">
<img src="sift-image-frame.png" alt="sift-image-frame.png"/>
</div>
<p>Then all quantities can be computed in the image frame directly. For instance, the image at infinite resolution in the two frames are related by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat I_0(\hat\mathbf{x}) = I_0(\mathbf{x}), \qquad \mathbf{x} = A \hat\mathbf{x} + T. \]" src="form_294.png"/>
</p>
<p>The canonized image at scale <img class="formulaInl" alt="$ \hat \sigma $" src="form_295.png"/> is in relation with the scaled image</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat I_{\hat{\sigma}}(\hat\mathbf{x}) = I_{A\hat{\sigma}}(\mathbf{x}), \qquad \mathbf{x} = A \hat\mathbf{x} + T \]" src="form_296.png"/>
</p>
<p>where, by generalizing the previous definitions, we have</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ I_{A\hat \sigma}(\mathbf{x}) = (g_{A\hat\sigma} * I_0)(\mathbf{x}), \quad g_{A\hat\sigma}(\mathbf{x}) = \frac{1}{2\pi|A|\hat \sigma^2} \exp \left( -\frac{1}{2} \frac{\mathbf{x}^\top A^{-\top}A^{-1}\mathbf{x}}{\hat \sigma^2} \right) \]" src="form_297.png"/>
</p>
<p>Deriving shows that the gradient fields are in relation</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat J(\hat \mathbf{x}) = J(\mathbf{x}) A, \quad J(\mathbf{x}) = (\nabla I_{A\hat\sigma})(\mathbf{x}), \qquad \mathbf{x} = A \hat\mathbf{x} + T. \]" src="form_298.png"/>
</p>
<p>Therefore we can compute the descriptor either in the image or canonical frame as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} h(t,i,j) &amp;=&amp; \int g_{\hat \sigma_\mathrm{win}}(\hat \mathbf{x})\, w_\mathrm{ang}(\angle \hat J(\hat\mathbf{x}) - \theta_t)\, w_{ij}(\hat\mathbf{x})\, |\hat J(\hat \mathbf{x})|\, d\hat \mathbf{x} \\ &amp;=&amp; \int g_{A \hat \sigma_\mathrm{win}}(\mathbf{x} - T)\, w_\mathrm{ang}(\angle J(\mathbf{x})A - \theta_t)\, w_{ij}(A^{-1}(\mathbf{x} - T))\, |J(\mathbf{x})A|\, d\mathbf{x}. \end{eqnarray*}" src="form_299.png"/>
</p>
<p>where we defined the product of the two spatial binning functions</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_{ij}(\hat\mathbf{x}) = w(\hat x - \hat x_i) w(\hat y - \hat y_j) \]" src="form_300.png"/>
</p>
<p>In the actual implementation, this integral is computed by visiting a rectangular area of the image that fully contains the keypoint grid (along with half a bin border to fully include the bin windowing function). Since the descriptor can be rotated, this area is a rectangle of sides <img class="formulaInl" alt="$m/2\sqrt{2} (N_x+1,N_y+1)$" src="form_301.png"/> (see also the illustration).</p>
<h4><a class="anchor" id="sift-tech-descriptor-std"></a>
Standard SIFT descriptor</h4>
<p>For a SIFT-detected keypoint of center <img class="formulaInl" alt="$ T $" src="form_302.png"/>, scale <img class="formulaInl" alt="$ \sigma $" src="form_257.png"/> and orientation <img class="formulaInl" alt="$ \theta $" src="form_303.png"/>, the affine transformation <img class="formulaInl" alt="$ (A,T) $" src="form_304.png"/> reduces to the similarity transformation</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{x} = m \sigma R(\theta) \hat \mathbf{x} + T \]" src="form_305.png"/>
</p>
<p>where <img class="formulaInl" alt="$ R(\theta) $" src="form_306.png"/> is a counter-clockwise rotation of <img class="formulaInl" alt="$ \theta $" src="form_303.png"/> radians, <img class="formulaInl" alt="$ m \mathcal{\sigma} $" src="form_307.png"/> is the size of a descriptor bin in pixels, and <em>m</em> is the <b>descriptor magnification factor</b> which expresses how much larger a descriptor bin is compared to the scale of the keypoint <img class="formulaInl" alt="$ \sigma $" src="form_257.png"/> (the default value is <em>m</em> = 3). Moreover, the standard SIFT descriptor computes the image gradient at the scale of the keypoints, which in the canonical frame is equivalent to a smoothing of <img class="formulaInl" alt="$ \hat \sigma = 1/m $" src="form_308.png"/>. Finally, the default Gaussian window size is set to have standard deviation <img class="formulaInl" alt="$ \hat \sigma_\mathrm{win} = 2 $" src="form_309.png"/>. This yields the formula</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} h(t,i,j) &amp;=&amp; m \sigma \int g_{\sigma_\mathrm{win}}(\mathbf{x} - T)\, w_\mathrm{ang}(\angle J(\mathbf{x}) - \theta - \theta_t)\, w_{ij}\left(\frac{R(\theta)^\top \mathbf{x} - T}{m\sigma}\right)\, |J(\mathbf{x})|\, d\mathbf{x}, \\ \sigma_{\mathrm{win}} &amp;=&amp; m\sigma\hat \sigma_{\mathrm{win}}, \\ J(\mathbf{x}) &amp;=&amp; \nabla (g_{m \sigma \hat \sigma} * I)(\mathbf{x}) = \nabla (g_{\sigma} * I)(\mathbf{x}) = \nabla I_{\sigma} (\mathbf{x}). \end{eqnarray*}" src="form_310.png"/>
</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Andrea Vedaldi </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a19140d86df12ff8c211c2728209de9b1"></a><!-- doxytag: member="sift.h::vl_sift_calc_keypoint_descriptor" ref="a19140d86df12ff8c211c2728209de9b1" args="(VlSiftFilt *f, vl_sift_pix *descr, VlSiftKeypoint const *k, double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_calc_keypoint_descriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> *&#160;</td>
          <td class="paramname"> <em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> const *&#160;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>angle0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">descr</td><td>SIFT descriptor (output) </td></tr>
    <tr><td class="paramname">k</td><td>keypoint. </td></tr>
    <tr><td class="paramname">angle0</td><td>keypoint direction.</td></tr>
  </table>
  </dd>
</dl>
<p>The function computes the SIFT descriptor of the keypoint <em>k</em> of orientation <em>angle0</em>. The function fills the buffer <em>descr</em> which must be large enough to hold the descriptor.</p>
<p>The function assumes that the keypoint is on the current octave. If not, it does not do anything. </p>

</div>
</div>
<a class="anchor" id="a2e409d464f81582dc3e839bf0fece66e"></a><!-- doxytag: member="sift.h::vl_sift_calc_keypoint_orientations" ref="a2e409d464f81582dc3e839bf0fece66e" args="(VlSiftFilt *f, double angles[4], VlSiftKeypoint const *k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_calc_keypoint_orientations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>angles</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> const *&#160;</td>
          <td class="paramname"> <em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">angles</td><td>orientations (output). </td></tr>
    <tr><td class="paramname">k</td><td>keypoint.</td></tr>
  </table>
  </dd>
</dl>
<p>The function computes the orientation(s) of the keypoint <em>k</em>. The function returns the number of orientations found (up to four). The orientations themselves are written to the vector <em>angles</em>.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function requires the keypoint octave <em>k-&gt;o</em> to be equal to the filter current octave <a class="el" href="sift_8h.html#a400759060e87dc7a6264555b90b0a221" title="Get current octave data.">vl_sift_get_octave</a>. If this is not the case, the function returns zero orientations.</dd>
<dd>
The function requires the keypoint scale level <code>k-&gt;s</code> to be in the range <code>s_min+1</code> and <code>s_max-2</code> (where usually <code>s_min=0</code> and <code>s_max=S+2</code>). If this is not the case, the function returns zero orientations.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of orientations found. </dd></dl>

</div>
</div>
<a class="anchor" id="a46d3e864618b4a940c2099b7c1f7b6a6"></a><!-- doxytag: member="sift.h::vl_sift_calc_raw_descriptor" ref="a46d3e864618b4a940c2099b7c1f7b6a6" args="(VlSiftFilt const *f, vl_sift_pix const *image, vl_sift_pix *descr, int widht, int height, double x, double y, double s, double angle0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_calc_raw_descriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> const *&#160;</td>
          <td class="paramname"> <em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> *&#160;</td>
          <td class="paramname"> <em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>angle0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">grad</td><td>image gradients. </td></tr>
    <tr><td class="paramname">descr</td><td>SIFT descriptor (output). </td></tr>
    <tr><td class="paramname">width</td><td>image width. </td></tr>
    <tr><td class="paramname">height</td><td>image height. </td></tr>
    <tr><td class="paramname">x</td><td>keypoint x coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>keypoint y coordinate. </td></tr>
    <tr><td class="paramname">sigma</td><td>keypoint scale. </td></tr>
    <tr><td class="paramname">angle0</td><td>keypoint orientation.</td></tr>
  </table>
  </dd>
</dl>
<p>The function runs the SIFT descriptor on raw data. Here <em>image</em> is a 2 x <em>width</em> x <em>height</em> array (by convention, the memory layout is a s such the first index is the fastest varying one). The first <em>width</em> x <em>height</em> layer of the array contains the gradient magnitude and the second the gradient angle (in radians, between 0 and <img class="formulaInl" alt="$ 2\pi $" src="form_312.png"/>). <em>x</em>, <em>y</em> and <em>sigma</em> give the keypoint center and scale respectively.</p>
<p>In order to be equivalent to a standard SIFT descriptor the image gradient must be computed at a smoothing level equal to the scale of the keypoint. In practice, the actual SIFT algorithm makes the following additional approximation, which influence the result:</p>
<ul>
<li>Scale is discretized in <code>S</code> levels.</li>
<li>The image is downsampled once for each octave (if you do this, the parameters <em>x</em>, <em>y</em> and <em>sigma</em> must be scaled too). </li>
</ul>

</div>
</div>
<a class="anchor" id="ab242293326626641411e7d7f43a109b2"></a><!-- doxytag: member="sift.h::vl_sift_delete" ref="ab242293326626641411e7d7f43a109b2" args="(VlSiftFilt *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter to delete.</td></tr>
  </table>
  </dd>
</dl>
<p>The function frees the resources allocated by <a class="el" href="sift_8c.html#adff66a155e30ed412bc8bbb97dfa2fae" title="Create a new SIFT filter.">vl_sift_new()</a>. </p>

</div>
</div>
<a class="anchor" id="a65c55820964f4f6609ca9ef1d547b2c4"></a><!-- doxytag: member="sift.h::vl_sift_detect" ref="a65c55820964f4f6609ca9ef1d547b2c4" args="(VlSiftFilt *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function detect keypoints in the current octave filling the internal keypoint buffer. Keypoints can be retrieved by <a class="el" href="sift_8h.html#a8d7878f102c5e09b2df06b3662ed9c6a" title="Get keypoints.">vl_sift_get_keypoints()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>

<p><p>Index GSS</p>
<p>Index matrix A </p>
</p>

</div>
</div>
<a class="anchor" id="adb5b0159af92e1ce1462ddaaaa55a747"></a><!-- doxytag: member="sift.h::vl_sift_get_edge_thresh" ref="adb5b0159af92e1ce1462ddaaaa55a747" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_sift_get_edge_thresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>threshold. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d7878f102c5e09b2df06b3662ed9c6a"></a><!-- doxytag: member="sift.h::vl_sift_get_keypoints" ref="a8d7878f102c5e09b2df06b3662ed9c6a" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> const * vl_sift_get_keypoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the keypoints list. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0272723812d5072619475d4787be78e"></a><!-- doxytag: member="sift.h::vl_sift_get_magnif" ref="ae0272723812d5072619475d4787be78e" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_sift_get_magnif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>magnification factor. </dd></dl>

</div>
</div>
<a class="anchor" id="aa45b8e7413384c7d6525f439e68856fe"></a><!-- doxytag: member="sift.h::vl_sift_get_nkeypoints" ref="aa45b8e7413384c7d6525f439e68856fe" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_get_nkeypoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of keypoints. </dd></dl>

</div>
</div>
<a class="anchor" id="a751c116352e72eed8a111e7c1e06a18e"></a><!-- doxytag: member="sift.h::vl_sift_get_nlevels" ref="a751c116352e72eed8a111e7c1e06a18e" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_get_nlevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of leves per octave. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e0cd96b3985635b82adabc3ce8b2242"></a><!-- doxytag: member="sift.h::vl_sift_get_noctaves" ref="a5e0cd96b3985635b82adabc3ce8b2242" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_get_noctaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of octaves. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4b57c390ca004dc56b0b0b1abf0c7a9"></a><!-- doxytag: member="sift.h::vl_sift_get_norm_thresh" ref="ad4b57c390ca004dc56b0b0b1abf0c7a9" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_sift_get_norm_thresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>threshold. </dd></dl>

</div>
</div>
<a class="anchor" id="a400759060e87dc7a6264555b90b0a221"></a><!-- doxytag: member="sift.h::vl_sift_get_octave" ref="a400759060e87dc7a6264555b90b0a221" args="(VlSiftFilt const *f, int s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> * vl_sift_get_octave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">s</td><td>level index.</td></tr>
  </table>
  </dd>
</dl>
<p>The level index <em>s</em> ranges in the interval <code>s_min = -1</code> and <code> s_max = S + 2</code>, where <code>S</code> is the number of levels per octave.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the octave data for level <em>s</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3db07e91c86f992c31b8e2335a760a9"></a><!-- doxytag: member="sift.h::vl_sift_get_octave_first" ref="aa3db07e91c86f992c31b8e2335a760a9" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_get_octave_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>------------------------------------------------------------------- </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index of the first octave. </dd></dl>

</div>
</div>
<a class="anchor" id="a9769e8f6d84ec75804e873229526eb10"></a><!-- doxytag: member="sift.h::vl_sift_get_octave_height" ref="a9769e8f6d84ec75804e873229526eb10" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_get_octave_height </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>current octave height. </dd></dl>

</div>
</div>
<a class="anchor" id="a70186e579c8eff1bcabf408f46169cad"></a><!-- doxytag: member="sift.h::vl_sift_get_octave_index" ref="a70186e579c8eff1bcabf408f46169cad" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_get_octave_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index of the current octave. </dd></dl>

</div>
</div>
<a class="anchor" id="a89bd76ab5c1e584ff8e46dfdc93ea748"></a><!-- doxytag: member="sift.h::vl_sift_get_octave_width" ref="a89bd76ab5c1e584ff8e46dfdc93ea748" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_get_octave_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>current octave width. </dd></dl>

</div>
</div>
<a class="anchor" id="a08959e6a90c98bf397e3430e79a6ea9c"></a><!-- doxytag: member="sift.h::vl_sift_get_peak_thresh" ref="a08959e6a90c98bf397e3430e79a6ea9c" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_sift_get_peak_thresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>threshold ; </dd></dl>

</div>
</div>
<a class="anchor" id="a76053a5e655b9577995fea0fbe429078"></a><!-- doxytag: member="sift.h::vl_sift_get_window_size" ref="a76053a5e655b9577995fea0fbe429078" args="(VlSiftFilt const *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_sift_get_window_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>standard deviation of the Gaussian window (in spatial bin units). </dd></dl>

</div>
</div>
<a class="anchor" id="a6f3fc8e38b6c0c520cb90b1a63ddc031"></a><!-- doxytag: member="sift.h::vl_sift_keypoint_init" ref="a6f3fc8e38b6c0c520cb90b1a63ddc031" args="(VlSiftFilt const *f, VlSiftKeypoint *k, double x, double y, double sigma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_keypoint_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> const *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVlSiftKeypoint.html">VlSiftKeypoint</a> *&#160;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">k</td><td>SIFT keypoint (output). </td></tr>
    <tr><td class="paramname">x</td><td>x coordinate of the keypoint center. </td></tr>
    <tr><td class="paramname">y</td><td>y coordinate of the keypoint center. </td></tr>
    <tr><td class="paramname">sigma</td><td>keypoint scale.</td></tr>
  </table>
  </dd>
</dl>
<p>The function initializes a keypoint structure <em>k</em> from the location <em>x</em> and <em>y</em> and the scale <em>sigma</em> of the keypoint. The keypoint structure maps the keypoint to an octave and scale level of the discretized Gaussian scale space, which is required for instance to compute the keypoint SIFT descriptor.</p>
<dl class="user"><dt><b>Algorithm</b></dt><dd></dd></dl>
<p>The formula linking the keypoint scale sigma to the octave and scale indexes is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sigma(o,s) = \sigma_0 2^{o+s/S} \]" src="form_313.png"/>
</p>
<p>In addition to the scale index <em>s</em> (which can be fractional due to scale interpolation) a keypoint has an integer scale index <em>is</em> too (which is the index of the scale level where it was detected in the DoG scale space). We have the constraints (<a class="el" href="sift_8h.html#sift-tech-detector">Detector</a> see also the "SIFT detector"):</p>
<ul>
<li><em>o</em> is integer in the range <img class="formulaInl" alt="$ [o_\mathrm{min}, o_{\mathrm{min}}+O-1] $" src="form_314.png"/>.</li>
<li><em>is</em> is integer in the range <img class="formulaInl" alt="$ [s_\mathrm{min}+1, s_\mathrm{max}-2] $" src="form_315.png"/>. This depends on how the scale is determined during detection, and must be so here because gradients are computed only for this range of scale levels and are required for the calculation of the SIFT descriptor.</li>
<li><img class="formulaInl" alt="$ |s - is| < 0.5 $" src="form_316.png"/> for detected keypoints in most cases due to the interpolation technique used during detection. However this is not necessary.</li>
</ul>
<p>Thus octave o represents scales <img class="formulaInl" alt="$ \{ \sigma(o, s) : s \in [s_\mathrm{min}+1-.5, s_\mathrm{max}-2+.5] \} $" src="form_317.png"/>. Note that some scales may be represented more than once. For each scale, we select the largest possible octave that contains it, i.e.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ o(\sigma) = \max \{ o \in \mathbb{Z} : \sigma_0 2^{\frac{s_\mathrm{min}+1-.5}{S}} \leq \sigma \} = \mathrm{floor}\,\left[ \log_2(\sigma / \sigma_0) - \frac{s_\mathrm{min}+1-.5}{S}\right] \]" src="form_318.png"/>
</p>
<p>and then</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ s(\sigma) = S \left[\log_2(\sigma / \sigma_0) - o(\sigma)\right], \quad is(\sigma) = \mathrm{round}\,(s(\sigma)) \]" src="form_319.png"/>
</p>
<p>In practice, both <img class="formulaInl" alt="$ o(\sigma) $" src="form_320.png"/> and <img class="formulaInl" alt="$ is(\sigma) $" src="form_321.png"/> are clamped to their feasible range as determined by the SIFT filter parameters. </p>

</div>
</div>
<a class="anchor" id="adff66a155e30ed412bc8bbb97dfa2fae"></a><!-- doxytag: member="sift.h::vl_sift_new" ref="adff66a155e30ed412bc8bbb97dfa2fae" args="(int width, int height, int noctaves, int nlevels, int o_min)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a>* vl_sift_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>noctaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>o_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>image width. </td></tr>
    <tr><td class="paramname">height</td><td>image height. </td></tr>
    <tr><td class="paramname">noctaves</td><td>number of octaves. </td></tr>
    <tr><td class="paramname">nlevels</td><td>number of levels per octave. </td></tr>
    <tr><td class="paramname">o_min</td><td>first octave index.</td></tr>
  </table>
  </dd>
</dl>
<p>The function allocates and returns a new SIFT filter for the specified image and scale space geometry.</p>
<p>Setting <em>O</em> to a negative value sets the number of octaves to the maximum possible value depending on the size of the image.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new SIFT filter. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sift_8c.html#ab242293326626641411e7d7f43a109b2" title="Delete SIFT filter.">vl_sift_delete()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a97cca9a09efaadc9dd0671912b9d5e05"></a><!-- doxytag: member="sift.h::vl_sift_process_first_octave" ref="a97cca9a09efaadc9dd0671912b9d5e05" args="(VlSiftFilt *f, vl_sift_pix const *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_process_first_octave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sift_8h.html#a7efac4fb08e4642f12ef439ac376a5cc">vl_sift_pix</a> const *&#160;</td>
          <td class="paramname"> <em>im</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">im</td><td>image data.</td></tr>
  </table>
  </dd>
</dl>
<p>The function starts processing a new image by computing its Gaussian scale space at the lower octave. It also empties the internal keypoint buffer.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code. The function returns <a class="el" href="generic_8h.html#a67cc69e40d7af2aec137b36e53422982">VL_ERR_EOF</a> if there are no more octaves to process.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sift_8c.html#a610cab1a3bf7d38e389afda9037f14da" title="Process next octave.">vl_sift_process_next_octave()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a610cab1a3bf7d38e389afda9037f14da"></a><!-- doxytag: member="sift.h::vl_sift_process_next_octave" ref="a610cab1a3bf7d38e389afda9037f14da" args="(VlSiftFilt *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_sift_process_next_octave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter.</td></tr>
  </table>
  </dd>
</dl>
<p>The function computes the next octave of the Gaussian scale space. Notice that this clears the record of any feature detected in the previous octave.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code. The function returns the error <a class="el" href="generic_8h.html#a67cc69e40d7af2aec137b36e53422982">VL_ERR_EOF</a> when there are no more octaves to process.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sift_8c.html#a97cca9a09efaadc9dd0671912b9d5e05" title="Start processing a new image.">vl_sift_process_first_octave()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7173b402b85de43ebf36fcabde77508"></a><!-- doxytag: member="sift.h::vl_sift_set_edge_thresh" ref="ab7173b402b85de43ebf36fcabde77508" args="(VlSiftFilt *f, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_set_edge_thresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">t</td><td>threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a595579dd7952807c074c5311a6500121"></a><!-- doxytag: member="sift.h::vl_sift_set_magnif" ref="a595579dd7952807c074c5311a6500121" args="(VlSiftFilt *f, double m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_set_magnif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">m</td><td>magnification factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86703f33aad31638909acd9697f93115"></a><!-- doxytag: member="sift.h::vl_sift_set_norm_thresh" ref="a86703f33aad31638909acd9697f93115" args="(VlSiftFilt *f, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_set_norm_thresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">t</td><td>threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af69118a1c5d4d17bccac87d11fe8ce8f"></a><!-- doxytag: member="sift.h::vl_sift_set_peak_thresh" ref="af69118a1c5d4d17bccac87d11fe8ce8f" args="(VlSiftFilt *f, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_set_peak_thresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">t</td><td>threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5996cc6171c6e3c8810fb400abbad21"></a><!-- doxytag: member="sift.h::vl_sift_set_window_size" ref="af5996cc6171c6e3c8810fb400abbad21" args="(VlSiftFilt *f, double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_sift_set_window_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlSiftFilt.html">VlSiftFilt</a> *&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>SIFT filter. </td></tr>
    <tr><td class="paramname">x</td><td>Gaussian window size (in units of spatial bin).</td></tr>
  </table>
  </dd>
</dl>
<p>This is the parameter <img class="formulaInl" alt="$ \hat \sigma_{\text{win}} $" src="form_322.png"/> of the standard SIFT descriptor <a class="el" href="sift_8h.html#sift-tech-descriptor-std">Standard SIFT descriptor</a>. </p>

</div>
</div>
</div>
     <!-- Doc Here -->
    </div>
   
   </div>
   <div class="clear">&nbsp;</div>
  </div> <!-- pagebody -->
  <div id="footer">
   &copy; 2005-11 Andrea Vedaldi and Brian Fulkerson
  </div> <!-- footer -->

  <!-- Google Analytics Begins -->
  <script xml:space="preserve" type="text/javascript">
   //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {
   var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
   document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
   }
   //]]>
  </script>
  <script xml:space="preserve" type="text/javascript">
    //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {

   try {
   var pageTracker = _gat._getTracker("UA-4936091-2");
   pageTracker._trackPageview();
   } catch(err) {}

   }
   //]]>
  </script>
  <!-- Google Analytics Ends -->
 </body>
</html>

 
